/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Gaussian core + exponential tail
// Souvik Das
// 8/1/2013

#include "Riostream.h" 

#include "RooGaussExp.h" 
//#include "RooAbsReal.h" 
//#include "RooAbsCategory.h" 
//#include <math.h> 
//#include "TMath.h" 

ClassImp(RooGaussExp) 

RooGaussExp::RooGaussExp(const char *name, const char *title, 
                       RooAbsReal& _x,
                       RooAbsReal& _mean,
                       RooAbsReal& _sigma,
                       RooAbsReal& _lambda,
                       Type type) :
  RooAbsPdf(name,title), 
  x("x","x",this,_x),
  mean("mean","mean",this,_mean),
  sigma("sigma","sigma",this,_sigma),
  lambda("lambda","lambda",this,_lambda),
  _flip(type==Flipped)
{ 
} 


RooGaussExp::RooGaussExp(const RooGaussExp& other, const char* name) :  
  RooAbsPdf(other,name), 
  x("x",this,other.x),
  mean("mean",this,other.mean),
  sigma("sigma",this,other.sigma),
  lambda("lambda",this,other.lambda),
  _flip(other._flip)
{ 
} 

Double_t RooGaussExp::evaluate() const 
{
  Double_t std = (x-mean)/sigma;
  Double_t result = 0;
  
  if (_flip ? std>lambda : std<lambda) {
    result = exp(-std*std/2.);
  } else {
    result = exp(lambda*lambda/2.-lambda*std);
  }
  
  return result; 
} 


////_____________________________________________________________________________
//Int_t RooGaussExp::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /*rangeName*/) const
//{
//  if (matchArgs(allVars,analVars,x)) return 1 ;
//  if (matchArgs(allVars,analVars,mean)) return 2 ;
//  return 0 ;
//}
//
//
////_____________________________________________________________________________
//Double_t RooGaussExp::analyticalIntegral(Int_t code, const char* rangeName) const
//{
//  assert(code==1 || code==2) ;
//
//  static Double_t root2 = sqrt(2.) ;
//  static Double_t rootPiBy2 = sqrt(atan2(0.0,-1.0)/2.0);
//  Double_t xscale = root2*sigma;
//  Double_t stdmax = (x.max(rangeName)-mean)/sigma;
//  Double_t stdmin = (x.min(rangeName)-mean)/sigma;
//  Double_t ret = 0;
//  if(code==1){
//    if (_flip ? stdmin>lambda : stdmax<lambda) {
//      ret = rootPiBy2*sigma*(RooMath::erf(stdmax/root2)-RooMath::erf(stdmin/root2));
//
//    } else if (_flip ? stdmax<lambda : stdmin>lambda ){
//      if(lambda == 0.0) {
//        ret = (x.max(rangeName) - x.min(rangeName));
//      } else {
//        ret = ( exp( lambda*lambda/2.-lambda*stdmax ) - exp( lambda*lambda/2.-lambda*stdmin ) )*(-sigma/lambda);
//      }
//      //cout << "stdmin="  << stdmin << ", stdmax=" << stdmax << ", lambda=" << lambda << ", mean=" << mean << ", sigma=" << sigma << ", ret=" << ret <<  endl;
//
//    } else {
//      if (_flip) {
//        assert(stdmin <= lambda && lambda <= stdmax);
//        ret = rootPiBy2*sigma*(RooMath::erf(stdmax/root2)-RooMath::erf(lambda/root2));
//        if(lambda == 0.0) {
//          ret += (0.0 - x.min(rangeName));
//        } else {
//          ret += ( exp( -lambda*lambda/2. ) - exp( lambda*lambda/2.-lambda*stdmin ) )*(-sigma/lambda);
//        }
//      } else {
//        assert(stdmin <= lambda && lambda <= stdmax);
//        ret = rootPiBy2*sigma*(RooMath::erf(lambda/root2)-RooMath::erf(stdmin/root2));
//        if(lambda == 0.0) {
//          ret += (x.max(rangeName) - 0.0);
//        } else {
//          ret += ( exp( lambda*lambda/2.-lambda*stdmax ) - exp( -lambda*lambda/2. ) )/(-sigma/lambda);
//        }
//      }
//      //cout << "stdmin="  << stdmin << ", stdmax=" << stdmax << ", lambda=" << lambda << ", mean=" << mean << ", sigma=" << sigma << ", ret=" << ret <<  endl;
//    }
//
//  } else if(code==2) {
//    cout << "Error in RooGaussExp::analyticalIntegral: Not implemented " << endl;
//
//  } else {
//    cout << "Error in RooGaussExp::analyticalIntegral" << endl;
//  }
//  //cout << ret << endl;
//  return ret ;
//}



/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "RooEMGaussian.h" 
//#include "RooAbsReal.h" 
//#include "RooAbsCategory.h" 
//#include <math.h> 
//#include "TMath.h"

ClassImp(RooEMGaussian) 

RooEMGaussian::RooEMGaussian(const char *name, const char *title, 
                       RooAbsReal& _x,
                       RooAbsReal& _mean,
                       RooAbsReal& _sigma,
                       RooAbsReal& _lambda,
                       Type type) :
  RooAbsPdf(name,title), 
  x("x","x",this,_x),
  mean("mean","mean",this,_mean),
  sigma("sigma","sigma",this,_sigma),
  lambda("lambda","lambda",this,_lambda),
  _flip(type==Flipped),
  _asympInt(kFALSE)
{ 
} 


RooEMGaussian::RooEMGaussian(const RooEMGaussian& other, const char* name) :  
  RooAbsPdf(other,name), 
  x("x",this,other.x),
  mean("mean",this,other.mean),
  sigma("sigma",this,other.sigma),
  lambda("lambda",this,other.lambda),
  _flip(other._flip),
  _asympInt(other._asympInt)
{ 
} 


// Adapted from RooGExpModel
Double_t RooEMGaussian::evaluate() const 
{ 
  static Double_t root2(sqrt(2.)) ;
  Double_t fsign = _flip?-1:1 ;
  Double_t expArg = lambda*lambda * sigma*sigma / 2.0 + fsign * lambda * (x - mean) ;
  Double_t erfArg = ((lambda * sigma*sigma) + (fsign * (x - mean))) / (root2 * sigma) ;
  Double_t result = 0 ;
  if (expArg<300) {
    result = lambda / 2.0 * exp(expArg) * RooMath::erfc(erfArg) ;
  } else {
    // If exponent argument is very large, bring canceling RooMath::erfc() term inside exponent
    // to avoid floating point over/underflows of intermediate calculations
    result = lambda / 2.0 * exp(expArg + logErfC(erfArg)) ;
  }

  return result ;
} 



//Int_t RooEMGaussian::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /*rangeName*/) const  
//{ 
//  // LIST HERE OVER WHICH VARIABLES ANALYTICAL INTEGRATION IS SUPPORTED, 
//  // ASSIGN A NUMERIC CODE FOR EACH SUPPORTED (SET OF) PARAMETERS 
//  // THE EXAMPLE BELOW ASSIGNS CODE 1 TO INTEGRATION OVER VARIABLE X
//  // YOU CAN ALSO IMPLEMENT MORE THAN ONE ANALYTICAL INTEGRAL BY REPEATING THE matchArgs 
//  // EXPRESSION MULTIPLE TIMES
//
//  if (matchArgs(allVars,analVars,x)) return 1 ; 
//  return 0 ; 
//} 


//// Adapted from RooGExpModel
//Double_t RooEMGaussian::analyticalIntegral(Int_t code, const char* rangeName) const  
//{ 
//  // RETURN ANALYTICAL INTEGRAL DEFINED BY RETURN CODE ASSIGNED BY getAnalyticalIntegral
//  // THE MEMBER FUNCTION x.min(rangeName) AND x.max(rangeName) WILL RETURN THE INTEGRATION
//  // BOUNDARIES FOR EACH OBSERVABLE x
//
//  assert(code==1) ; 
//  //return (x.max(rangeName)-x.min(rangeName)) ; 
//
//  static Double_t root2(sqrt(2.)) ;
//  Double_t fsign = _flip?-1:1 ;
//  Double_t xpmin = lambda * x.min(rangeName) ;
//  Double_t xpmax = lambda * x.max(rangeName) ;
//  Double_t xpmean = lambda * mean ;
//  Double_t c = lambda * sigma / root2;
//  Double_t umin = (xpmin - xpmean)/(2.0*c) ;
//  Double_t umax = (xpmax - xpmean)/(2.0*c) ;
//  Double_t result = 0 ;
//  if (_asympInt) {
//    result = 1.0 ;
//  } else {
//    result = 0.5 * lambda * evalCerfInt(-fsign,lambda,fsign*umin,fsign*umax,c) ;
//  }
//  return result ; 
//} 



//Int_t RooEMGaussian::getGenerator(const RooArgSet& directVars, RooArgSet &generateVars, Bool_t /*staticInitOK*/) const 
//{ 
//  // LIST HERE OVER WHICH VARIABLES INTERNAL GENERATION IS SUPPORTED, 
//  // ASSIGN A NUMERIC CODE FOR EACH SUPPORTED (SET OF) PARAMETERS 
//  // THE EXAMPLE BELOW ASSIGNS CODE 1 TO INTEGRATION OVER VARIABLE X
//  // YOU CAN ALSO IMPLEMENT MORE THAN ONE GENERATOR CONFIGURATION BY REPEATING THE matchArgs 
//  // EXPRESSION MULTIPLE TIMES. IF THE FLAG staticInitOK IS TRUE THEN IT IS SAFE TO PRECALCULATE 
//  // INTERMEDIATE QUANTITIES IN initGenerator(), IF IT IS NOT SET THEN YOU SHOULD NOT ADVERTISE
//  // ANY GENERATOR METHOD THAT RELIES ON PRECALCULATIONS IN initGenerator()
//
//  // if (matchArgs(directVars,generateVars,x)) return 1 ;   
//  return 0 ; 
//} 



//void RooEMGaussian::generateEvent(Int_t code) 
//{ 
//  // GENERATE SET OF OBSERVABLES DEFINED BY RETURN CODE ASSIGNED BY getGenerator()
//  // RETURN THE GENERATED VALUES BY ASSIGNING THEM TO THE PROXY DATA MEMBERS THAT
//  // REPRESENT THE CHOSEN OBSERVABLES
//
//  // assert(code==1) ; 
//  // x = 0 ; 
//  return; 
//} 


//_____________________________________________________________________________
// Copied from RooGExpModel
Double_t RooEMGaussian::logErfC(Double_t xx) const
{
  // Approximation of the log of the complex error function
  Double_t t,z,ans;
  z=fabs(xx);
  t=1.0/(1.0+0.5*z);

  if(xx >= 0.0)
    ans=log(t)+(-z*z-1.26551223+t*(1.00002368+t*(0.37409196+t*(0.09678418+t*(-0.18628806+
        t*(0.27886807+t*(-1.13520398+t*(1.48851587+t*(-0.82215223+t*0.17087277)))))))));
  else
    ans=log(2.0-t*exp(-z*z-1.26551223+t*(1.00002368+t*(0.37409196+t*(0.09678418+t*(-0.18628806+
        t*(0.27886807+t*(-1.13520398+t*(1.48851587+t*(-0.82215223+t*0.17087277))))))))));

  return ans;
}

//_____________________________________________________________________________
// Copied from RooGExpModel
// Calculate Re(exp(-u^2) cwerf(i(u+c)))
Double_t RooEMGaussian::evalCerfRe(Double_t u, Double_t c) const {
  Double_t expArg = u*2*c+c*c ;
  if (expArg<300) {
     return exp(expArg) * RooMath::erfc(u+c);
  } else {
     return exp(expArg+logErfC(u+c));
  }
}

//_____________________________________________________________________________
// Copied from RooGExpModel
Double_t RooEMGaussian::evalCerfInt(Double_t sign, Double_t lamb, Double_t umin, Double_t umax, Double_t c) const
{
  Double_t diff;
  if (_asympInt) {
    diff = 2. ;
  } else {
    if ((umin<-8 && umax>8)||(umax<-8 && umin>8)) {
      // If integral is over >8 sigma, approximate with full integral
      diff = 2. ;
    } else {
      diff = sign*(evalCerfRe(umin,c) - evalCerfRe(umax,c) + RooMath::erf(umin) - RooMath::erf(umax));
    }
  }
  return (1.0/lamb * diff);
}


